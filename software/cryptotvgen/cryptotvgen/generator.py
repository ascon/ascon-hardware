# -*- coding: utf-8 -*-

# cryptotvgen
# Ekawat (Ice) Homsirikimal and William Diehl
#
# Based on aeadtvgen 2.0.0 by Ekawat Homsirikamol (GMU CERG)

import binascii
import cffi
import math
import os
import random
import math
import sys
from pathlib import Path
from pkg_resources import get_distribution, DistributionNotFound
from enum import Enum

from .options import routines
from .log import setup_logger
from .prepare_libs import ctgen_get_supercop_dir


__all__ = ['gen_random', 'gen_dataset', 'gen_test_routine',
           'gen_single', 'print_header', 'gen_hash', 'gen_test_combined']

from .__init__ import __version__


ffi = cffi.FFI()
ffi.cdef('''
    int crypto_aead_encrypt(
        unsigned char *c,unsigned long long *clen,
        const unsigned char *m,unsigned long long mlen,
        const unsigned char *ad,unsigned long long adlen,
        const unsigned char *nsec,
        const unsigned char *npub,
        const unsigned char *k
    );
    int crypto_aead_decrypt(
        unsigned char *m,unsigned long long *mlen,
        unsigned char *nsec,
        const unsigned char *c,unsigned long long clen,
        const unsigned char *ad,unsigned long long adlen,
        const unsigned char *npub,
        const unsigned char *k
    );
    int crypto_hash(unsigned char *out, const unsigned char *in, unsigned long long hlen);
    ''')

log = setup_logger('cryptotvgen.log')

HUMAN_READABLE_FILE = 'test_vectors.txt'
HLS_CC_DI_FILE = 'cc_di.txt'
HLS_CC_DO_FILE = 'cc_do.txt'

def print_header(opts):
    '''
    Print header file
    '''
    ignore_opts = {
        'lib_path', 'lib_file', 'dest', 'pdi_file', 'sdi_file', 'do_file', 'candidates_dir', 'supercop_version',
        'verify_lib', 'routines', 'verbose', 'mode', 'human_readable'} | set(routines)

    sorted_vars = [ x for x in sorted(vars(opts)) if x not in ignore_opts ]

    txt = "# This file was auto-generated by cryptotvgen v{}\n" \
        .format(__version__)
    txt += '#'*79 + '\n'
    txt += '# Parameter:\n'
    txt += '#\n'

    for opt in sorted_vars:
        value = getattr(opts, opt)
        if opt == 'io':
            opt = 'io (W,SW)'
        elif opt == 'block_size_ad':
            if value == None:
                continue
        txt += "# {:22} - {}\n".format(opt, value)
    txt += '#'*79 + '\n\n'


    for file_name in [opts.pdi_file, opts.sdi_file, opts.do_file]:
        file_path = os.path.join(opts.dest,file_name)
        with open(file_path, 'w', newline='') as f:
            f.write('#'*79 + '\n')
            f.write('# {}\n'.format(file_name))
            f.write(txt)

    if opts.cc_hls:
        file_path = os.path.join(opts.dest,HLS_CC_DI_FILE)
        with open(file_path, 'w', newline='') as f:
            f.write('#DATA_FORMAT Data,Size,Type,Eoi,Eot,Partial\n')
            f.write('#BEGIN\n\n')
        file_path = os.path.join(opts.dest,HLS_CC_DO_FILE)
        with open(file_path, 'w', newline='') as f:
            f.write('#DATA_FORMAT Data,Size\n')
            f.write('#BEGIN\n\n')

    if opts.human_readable:
        file_path = os.path.join(opts.dest,HUMAN_READABLE_FILE)
        try:
            os.remove(file_path)
        except FileNotFoundError:
            pass


class Opcode(Enum):
    #hash = 1
    encrypt = 2
    decrypt = 3
    loadkey = 4
    actkey  = 7
    hash = 8

class Status(Enum):
    success = 14
    failure = 15

class Segment(Enum):
    ad      = 1
    npub_ad = 2
    ad_npub = 3
    pt      = 4
    ct      = 5
    ct_tag  = 6
    hash    = 7
    tag     = 8
    hash_tag = 9
    len     = 10
    key     = 12
    npub    = 13
    nsec_pt = 14
    nsec_ct = 15

class CC_Segment(Enum):
    ad    = 0
    ad1   = 1
    data  = 2
    data1 = 3
    tag   = 4
    len   = 5
    npub  = 6
    nsec  = 7
    hash = 8

txt_opcode = {
    Opcode.hash: 'Hash',
    Opcode.encrypt: 'Authenticated Encryption',
    Opcode.decrypt: 'Authenticated Decryption',
    Opcode.loadkey: 'Load Key',
    Opcode.actkey:  'Activate Key'}

txt_status = {
    Status.success: 'Success',
    Status.failure: 'Failure',}

txt_segment = {
    Segment.ad     : 'Associated Data',
    Segment.npub   : 'Npub',
    Segment.npub_ad: 'Npub || Associated Data',
    Segment.ad_npub: 'Associated Data || Npub',
    Segment.pt     : 'Plaintext',
    Segment.ct     : 'Ciphertext',
    Segment.ct_tag : 'Ciphertext || Tag',
    Segment.hash   : 'Hash',
    Segment.tag    : 'Tag',
    Segment.len    : 'Length',
    Segment.key    : 'Key',
    Segment.nsec_pt: 'Nsec (plain)',
    Segment.nsec_ct: 'Nsec (cipher)',
    Segment.hash_tag   : 'Hash_Tag'}

def lenbytes(hexstr):
    try:
        return int(math.ceil(len(hexstr)/2))
    except TypeError:
        return 0

def get_len(format, ad_len, pt_len):
    ''' Get segment length data hex format '''

    # Convert length to binary
    bin = '{:0{f[0]}b}{:0{f[1]}b}'.format(ad_len, pt_len, f=format)
    # Make sure data is byte multiple
    bin += '0'*int((-len(bin)) % 8)
    # Convert binary to hex string
    size = int(math.ceil((format[0]+format[1])/8))
    hex = '{:0{s}X}'.format(int(bin, 2), s=int(size*2))
    return hex

def get_msg_format(format, ofile, decrypt, hashop):
    ''' Create a msg format for pdi/sdi file '''

    msg_format = []
    tag = []
    for sgt in format:
        # Segment type format conversion
        if (not ofile): # Input file
            if sgt == 'data':
                if hashop:
                    sgt = 'hash'
                else:
                    sgt = 'ct' if (decrypt) else 'pt'
            elif sgt == 'data_tag':
                sgt = 'ct_tag' if (decrypt) else 'pt'
            elif sgt == 'nsec':
                sgt = 'nsec_ct' if (decrypt) else 'nsec_pt'
            elif sgt == 'tag':
                if (not decrypt):
                    continue
        else:   # output file check
            if sgt in ('npub', 'npub_ad', 'ad_npub', 'ad', 'len'):
                continue
            elif sgt == 'data':
                if hashop:
                    sgt = 'hash_tag'
                else:
                    sgt = 'ct' if (not decrypt) else 'pt'
            elif sgt == 'data_tag':
                sgt = 'ct_tag' if (not decrypt) else 'pt'
            elif sgt == 'nsec':
                sgt = 'nsec_ct' if (not decrypt) else 'nsec_pt'
            elif sgt == 'tag':
                if (decrypt):
                    continue
                else:   # Put tag in the last segment for output of encryption
                    tag.append(sgt)
                    continue

        msg_format.append(sgt)
    return msg_format + tag

def get_test_vector_info(msgid, keyid, ad_len, pt_len, ct_len, decrypt, hashop, hash_tag_size):
    ''' Get a string of test vector information '''
    if (hashop):
        optxt = txt_opcode[getattr(Opcode, 'hash')]
        data = 'Pt Size = {: 4}'.format(pt_len)
        data = 'Hash_Tag Size = {: 4}'.format(hash_tag_size) # change later
    elif (decrypt):
        optxt = txt_opcode[getattr(Opcode, 'decrypt')]
        data = 'Ct Size = {: 4}'.format(ct_len)
    else:
        optxt = txt_opcode[getattr(Opcode, 'encrypt')]
        data = 'Pt Size = {: 4}'.format(pt_len)
    txt  = '#### {}\n'.format(optxt)
    txt += '#### MsgID={: 3}, KeyID={: 3} '.format(msgid, keyid)
    txt += 'Ad Size = {: 4}, {}\n'.format(ad_len, data)
    return txt

def instr_info(f):
    def wrapper(*args, **kwargs):
        txt = '# Instruction: Opcode={}\n'.format(txt_opcode[args[1]])
        return '{}{}'.format(txt, f(*args, **kwargs))
    return wrapper

@instr_info
def build_instr(iowidth, opcode, msgid, keyid, ofile=0):
    ''' Generate instruction '''
    if (not ofile):
        binstr = '{:04b}'.format(opcode.value)
        binstr += '0'*(-len(binstr) % iowidth)
    else:
        binstr = '{:04b}{:08b}{:08b}'.format(opcode.value, keyid, msgid)
        iowidth = 20
    hexstr = '{:0{w}X}'.format(int(binstr, 2), w=int(iowidth/4))
    if (not ofile):
        return 'INS = {}\n'.format(hexstr)
    else:
        return '# TB :{} (Encoding used by testbench)\n'.format(hexstr)


def sgmt_info(f):
    def wrapper(*args, **kwargs):
        # Argument dissection
        data  = args[0]
        sgt   = args[1]
        ofile = args[2]
        opts  = args[3]
        (iowidth, io_per_line) = args[4]
        (is_partial, is_eoi, is_eot, is_lst) = args[5]

        pt_txt = 'Partial={} '.format(is_partial) \
            if opts.add_partial and sgt in ['pt','ct','ct_tag'] else ''
        last_txt = 'EOI={} '.format(is_eoi) if (not ofile) else ''
        txtsgmt = txt_segment[getattr(Segment, sgt)]
        txt = '# Info : {:>24}, '.format(txtsgmt)
        txt += '{}{}EOT={}, Last={}, Length={} bytes\n'.format(
            pt_txt, last_txt, is_eot, is_lst, lenbytes(data))
        return '{}{}'.format(txt, f(*args, **kwargs))
    return wrapper

def sgmt_hdr(f):
    def wrapper(*args, **kwargs):
        # Argument dissection
        data  = args[0]
        sgt   = args[1]
        ofile = args[2]
        opts  = args[3]
        (iowidth, io_per_line) = args[4]
        (is_partial, is_eoi, is_eot, is_lst) = args[5]

        is_eoi = is_eoi if (not ofile) else 0
        is_partial = is_partial \
            if opts.add_partial and sgt in ['pt','ct','ct_tag'] else 0
        code = getattr(Segment, sgt).value
        binstr = '{:04b}{}{}{}{}'.format(code, is_partial, is_eoi,
                                        is_eot, is_lst)
        binstr += '0'*8 + '{:016b}'.format(lenbytes(data))
        binstr += '0'*(-len(binstr) % iowidth)
        hexstr = '{:0{w}X}'.format(int(binstr, 2), w=int(iowidth/4))
        return 'HDR = {}\n{}'.format(hexstr, f(*args, **kwargs))
    return wrapper

@sgmt_info
@sgmt_hdr
def build_sgmt(data, sgt, ofile, opts, io_info, flags):
    ''' Generate a segment '''
    (iowidth, io_per_line) = io_info
    if len(data) > 0:
        bytes_per_line = iowidth/8*io_per_line
        tot_line = int(math.ceil(lenbytes(data)/bytes_per_line))
        txt = ''

        for i in range(tot_line):
            begin = int(i*bytes_per_line*2)
            end = begin + int(bytes_per_line*2)
            if i == tot_line-1:
                d = data[begin:]
                d += '00'*(-lenbytes(d) % int(iowidth/8))
                txt += 'DAT = {}\n'.format(d)
            else:
                txt += 'DAT = {}\n'.format(data[begin:end])
        return txt
    else :
        return ''


def build_status(iowidth):
    ''' Generate build status '''
    binstr = '{:04b}'.format(Status.success.value)
    binstr += '0'*(-len(binstr) % iowidth)
    hexstr = '{:0{w}X}'.format(int(binstr, 2), w=int(iowidth/4))
    txt = '# Status: Success\n'
    txt += 'STT = {}\n'.format(hexstr)
    return txt

def get_cffi_path(opts, hashop):
    if opts.lib_path:
        lib_path = Path(opts.lib_path)
    else:
        candidates_dir = Path(opts.candidates_dir) if opts.candidates_dir else ctgen_get_supercop_dir()
        lib_path = candidates_dir / 'lib'

    name = None
    if hashop:
        op = "hash"
        name = opts.hash
    else:
        op = "aead"
        name = opts.aead
    if not name:
        sys.exit(f'--{op} <ALGORITHM-VARIANT> not specified!')

    lib_ext = '.dll' if sys.platform in ['win32', 'win64', 'msys'] else '.so'
    libname = f'{name}{lib_ext}'
    cffi_path = lib_path / f'crypto_{op}' / libname
    if not cffi_path.exists():
        sys.exit(f'Dynamic library: {cffi_path} does not exist! Please make sure `lib_path` is correct and that you have already run `cryptotvgen --prepare_libs [--cadidates_dir=<PATH>]`?')
    return str(cffi_path)


class TestVector(object):
    ''' TestVector class '''
    BUFFER = '00'*128

    def __init__(self, opts, msg_id, key_id,
                 new_key, op, key, npub, nsec_pt, ad, pt, hashop):

        self.hashop = hashop
        cffi_path = get_cffi_path(opts, hashop)
        self.lib = ffi.dlopen(cffi_path)

        self.key_id = 0 if hashop else key_id
        self.opts = opts
        self.msg_id = msg_id
        self.new_key = new_key
        self.decrypt = op
        # Input
        self.key     = key
        self.npub    = npub[:int(2*self.opts.npub_size/8)]
        self.nsec_pt = nsec_pt[:int(2*self.opts.nsec_size/8)]
        self.ad      = ad
        self.pt      = pt
        self.partial = 0
        # Output
        self.nsec_ct = ''
        self.ct = ''
        self.tag = ''
        self.hash = pt
        self.hash_tag = ''
        self.hash_tag_size = self.opts.message_digest_size/8

    def aead_encrypt(self):
        ''' Compute aead algorithm '''
        pt_len  = lenbytes(self.pt)
        buf_len = lenbytes(self.BUFFER)
        # Prepare input to C function (add buffer to prevent overflow)
        m       = ffi.new("const unsigned char[]", binascii.unhexlify(self.pt + self.BUFFER))
        mlen    = ffi.cast("unsigned long long", pt_len)
        c       = ffi.new("unsigned char[]", binascii.unhexlify('00'*(pt_len+buf_len)))
        clen    = ffi.new("unsigned long long *", pt_len+buf_len)
        ad      = ffi.new("const unsigned char[]", binascii.unhexlify(self.ad + self.BUFFER))
        adlen   = ffi.cast("unsigned long long", lenbytes(self.ad))
        if (self.opts.nsec_size > 0):
            nsec = ffi.new("const unsigned char[]", binascii.unhexlify(self.nsec_pt))
        else:
            nsec = ffi.NULL
        npub    = ffi.new("const unsigned char[]", binascii.unhexlify(self.npub))
        key     = ffi.new("const unsigned char[]", binascii.unhexlify(self.key))
        ### ABI level, in-line call
        self.lib.crypto_aead_encrypt(c, clen, m, mlen, ad,
                                     adlen, nsec, npub, key)

        # Convert output to Hexadecimal
        output = "".join("{:0>2}".format(hex(c[i])[2:].upper()) for i in range(0, clen[0]))

        ns_len = int(self.opts.nsec_size/8*2)
        ct_len = int((clen[0]-self.opts.tag_size/8)*2-ns_len)
        partial = 0
        # Partial bit is located in the last byte
        if (self.opts.add_partial):
            ct_len = ct_len-2
            partial = output[-2:]

        nsec_ct = output[0:ns_len]
        ct  = output[ns_len:ns_len+ct_len]
        tag = output[ns_len+ct_len:ns_len+ct_len+int((self.opts.tag_size/8)*2)]

        return (nsec_ct, ct, tag, int(partial))

    def crypto_hash(self):
        ''' Compute aead algorithm '''
        pt_len  = lenbytes(self.pt)
        buf_len = lenbytes(self.BUFFER)
        # Prepare input to C function (add buffer to prevent overflow)
        m       = ffi.new("const unsigned char[]", binascii.unhexlify(self.pt + self.BUFFER))
        mlen    = ffi.cast("unsigned long long", pt_len)
        c       = ffi.new("unsigned char[]", binascii.unhexlify('00'*(pt_len+buf_len)))
        clen    = ffi.new("unsigned long long *", int(2*self.hash_tag_size)+buf_len)
        ### ABI level, in-line call
        self.lib.crypto_hash(c, m, mlen)

        # Convert output to Hexadecimal
        output = "".join("{:0>2}".format(hex(c[i])[2:].upper()) for i in range(0, int(self.hash_tag_size)))
        ct_len = 2*int(self.hash_tag_size)
        partial = 0
        # Partial bit is located in the last byte
        #if (self.opts.add_partial):
        #    ct_len = ct_len-2
        #    partial = output[-2:]

        ct  = output[0:ct_len]
        return (ct)

    def aead_decrypt(self):
        ''' Compute aead algorithm '''
        ns_len = int(self.opts.nsec_size/8)
        ct_len  = lenbytes(self.nsec_ct) \
                  + lenbytes(self.ct) \
                  + int(self.opts.tag_size/8)
        partial = ""
        if (self.opts.add_partial):
            ct_len = ct_len+1
            partial = "01"*self.partial

        buf_len = lenbytes(self.BUFFER)
        # Prepare input to C function (add buffer to prevent overflow)
        m       = ffi.new("unsigned char[]", binascii.unhexlify('00'*ct_len))
        mlen    = ffi.new("unsigned long long *", ct_len)
        if (self.opts.nsec_size > 0):
            nsec = ffi.new("unsigned char[]", binascii.unhexlify('00'*ns_len))
        else:
            nsec = ffi.NULL
        c       = ffi.new("const unsigned char[]", binascii.unhexlify(
                    self.nsec_ct + self.ct + self.tag + partial))
        clen    = ffi.cast("unsigned long long", ct_len)
        ad      = ffi.new("const unsigned char[]", binascii.unhexlify(self.ad + self.BUFFER))
        adlen   = ffi.cast("unsigned long long", lenbytes(self.ad))
        npub    = ffi.new("const unsigned char[]", binascii.unhexlify(self.npub))
        key     = ffi.new("const unsigned char[]", binascii.unhexlify(self.key))
        ### ABI level, in-line call
        auth_result = self.lib.crypto_aead_decrypt(m, mlen, nsec,
                                     c, clen, ad, adlen, npub, key)
        # Convert output to Hexadecimal
        pt = "".join("{:0>2}".format(hex(m[i])[2:].upper()) for i in range(0, mlen[0]))
        nsec_len = int(self.opts.nsec_size/8)
        nsec_pt = "".join("{:0>2}".format(hex(nsec[i])[2:].upper()) for i in range(0, nsec_len))

        return (auth_result, nsec_pt, pt)

    def get_data(self, sgt):
        ''' Get data based on segment type '''
        if (sgt == 'npub_ad'):
            data = getattr(self, 'npub') + getattr(self, 'ad')
        elif (sgt == 'ad_npub'):
            data = getattr(self, 'ad') + getattr(self, 'npub')
        elif (sgt == 'ct_tag'):
            data = getattr(self, 'ct') + getattr(self, 'tag')
        elif (sgt == 'len'):
            len_ad = lenbytes(self.ad)
            if self.decrypt:
                len_data = lenbytes(self.ct)
            else:
                len_data = lenbytes(self.pt)
            len_format = (32, 32)
            if (32 < self.opts.io[0] < 64):
                len_format = (self.opts.io[0], self.opts.io[0])
            data = get_len(len_format, len_ad, len_data)
        elif (sgt == 'hash_tag'):
            data = getattr(self, 'hash_tag')
        else:
            data = getattr(self, sgt)
        return data

    def is_last_vld_segment(self, sgt, msg_format):
        ''' Determine whether this segment is the last valid data segment '''
        ignore_sgts = ('len','tag', 'hash_tag')
        if sgt in ignore_sgts:
            return False
        if (sgt == 'hash'):
            return True
        if len(self.get_data(sgt)) <= 0:
            return False

        for i in range(msg_format.index(sgt)+1,len(msg_format)):
            if msg_format[i] in ignore_sgts:
                continue
            if len(self.get_data(msg_format[i])) > 0:
                return False
        return True

    def gen_tv(self):
        ''' Generate test vector files based on provided options '''
        if self.hashop:
            self.hash_tag = self.crypto_hash()
            self.partial = int(self.partial)

            log.info("== Hash")
            log.info("Msg = {}".format(self.pt))
            log.info("Md = {}".format(self.hash_tag))
        else:
            (self.nsec_ct, self.ct, self.tag, self.partial) = self.aead_encrypt()
            self.partial = int(self.partial)
            # Check for mismatching decrypted values and tag
            log.info("== AEAD Encrypt")
            log.info("Key = {}".format(self.key))
            log.info("Nonce = {}".format(self.npub))
            log.info("PT = {}".format(self.pt))
            log.info("AD = {}".format(self.ad))
            log.info("CT = {}{}".format(self.ct, self.tag))

            if (self.opts.verify_lib):
                if (self.opts.verbose):
                    print(" ====================== ")
                    print(" == Decryption Check == ")
                    print(" ====================== ")
                (auth_result, nsec_pt, pt) = self.aead_decrypt()
                log.info("== AEAD Decrypt")
                log.info("Auth result = {}".format(auth_result))
                log.info("Key = {}".format(self.key))
                log.info("Nonce = {}".format(self.npub))
                log.info("PT = {}".format(pt))
                log.info("AD = {}".format(self.ad))
                log.info("CT = {}{}".format(self.ct, self.tag))

                assert nsec_pt == self.nsec_pt
                assert pt == self.pt
                assert auth_result == 0

        (iow, iosw)  = self.opts.io
        io_info = (iow, self.opts.max_io_per_line)

        is_partial = self.partial

        # PDI and DO file
        for ofile, file_name in enumerate([self.opts.pdi_file,
                                           self.opts.do_file]):
            # Open file
            file_path = os.path.join(self.opts.dest, file_name)
            f = open(file_path, 'a', newline='')

            # Write Header
            txt = get_test_vector_info(self.msg_id,
                                       self.key_id,
                                       lenbytes(self.ad),
                                       lenbytes(self.pt),
                                       lenbytes(self.ct),
                                       self.decrypt,
                                       self.hashop,
                                       int(self.hash_tag_size))
            f.write('{}'.format(txt))

            if (not ofile):
                # Write New key
                if self.new_key:
                    txt = build_instr(iow, Opcode.actkey,
                                      self.msg_id, self.key_id)
                    f.write('{}'.format(txt))

            # Instruction
            if self.hashop:
                opcode = Opcode.hash
            elif self.decrypt:
                opcode = Opcode.decrypt
            else:
                opcode = Opcode.encrypt

            #opcode = Opcode.decrypt if self.decrypt else Opcode.encrypt
            txt = build_instr(iow, opcode, self.msg_id, self.key_id, ofile)

            f.write('{}'.format(txt))

            # Write Segment
            msg_format = get_msg_format(self.opts.msg_format,
                                        ofile, self.decrypt, self.hashop)
            for i, sgt in enumerate(msg_format):

                if self.hashop:
                    if sgt not in ['pt','ct','hash','hash_tag']:
                        continue

                # Data getter
                data = self.get_data(sgt)

                # Sub-segment
                max_sgmt = (self.opts.block_size/8)*self.opts.max_block_per_sgmt
                tot_sgmt = int(math.ceil(lenbytes(data)/max_sgmt))
                if (sgt in ['tag', 'hash_tag']):    # No segment split for tag/hash_tag
                    tot_sgmt = 1
                tot_sgmt = 1 if tot_sgmt == 0 else tot_sgmt

                (is_eoi, is_eot, is_lst) = (0,0,0)
                for j in range(tot_sgmt):
                    begin = int(j*max_sgmt*2)
                    end = begin + int(max_sgmt*2)
                    if j == tot_sgmt-1:
                        is_eoi = \
                            int(self.is_last_vld_segment(sgt, msg_format))
                        if (self.hashop and ofile):
                            is_lst = 1 if i == len(msg_format)-2 else 0
                        else:
                            is_lst = 1 if i == len(msg_format)-1 else 0
                        is_eot = 1
                        d = data[begin:]
                    else:
                        d = data[begin:end]
                    txt = ''

                    # ::Special rule for ciphertext expansion::
                    # Separates the last block in its own segment for
                    # ciphertext expansion mode to accommodate possible
                    # expansion/truncation of data.
                    #
                    # For plaintext, the last block can be empty to acommodate
                    # expected padding value.
                    #
                    # For ciphertext, the last block cannot be empty.
                    if (j == tot_sgmt-1
                            and self.opts.ciph_exp
                            and sgt in ['pt','ct','ct_tag']):
                        # Split d into d[1], d[2] if condition applies
                        rem = lenbytes(d) % int(self.opts.block_size/8)
                        if (lenbytes(d) >= int(self.opts.block_size/8)):
                            if (rem > 0):
                                d = (d[:-int(rem*2)], d[-int(rem*2):])
                            else:
                                if (sgt == 'pt' and not self.opts.ciph_exp_noext):
                                    d = (d, '')
                                else:
                                    if (lenbytes(d) == \
                                            int(self.opts.block_size/8)):
                                        d = (d, )
                                    else:
                                        rem = int(self.opts.block_size/8)
                                        d = (d[:-int(rem*2)], d[-int(rem*2):])
                        else:
                            d = (d, )

                        # Add intermediate block if necessary
                        if len(d) > 1:
                            if len(d[1]) == 0:
                                eoi = is_eoi
                                is_eoi = 0
                            else:
                                eoi = 0
                            flags = (is_partial, eoi, 0, 0)
                            txt += build_sgmt(d[0], sgt, ofile,
                                              self.opts, io_info, flags)
                            d = d[1]
                        else:
                            d = d[0]
                    flags = (is_partial, is_eoi, is_eot, is_lst)
                    txt += build_sgmt(d, sgt, ofile,
                                      self.opts, io_info, flags)

                    f.write('{}'.format(txt))

            if (ofile):
                # Write success
                txt = build_status(iow)
                f.write('{}'.format(txt))

            f.write('\n')
            f.close()


        # ==========
        # SDI file
        # ==========
        if (not self.new_key):
            return

        io_info = (iosw, self.opts.max_io_per_line)
        flags = (0, 1, 1, 1)
        sgt = 'key'

        file_path = os.path.join(self.opts.dest, self.opts.sdi_file)
        f = open(file_path, 'a', newline='')
        # Instruction
        txt  = '#### MsgID={: 3}, KeyID={: 3}\n'.format(self.msg_id,
                                                        self.key_id)
        txt += build_instr(iosw, Opcode.loadkey, self.msg_id, self.key_id)
        # Segment
        data = self.get_data(sgt)
        txt += build_sgmt(data, sgt, 0,
                          self.opts, io_info, flags)
        f.write('{}\n'.format(txt))
        f.close()


    def cc_pad(self, data, padmode, sgttype):
        # No padding
        if not self.opts.cc_pad_enable:
            return data;

        len = lenbytes(data)
        if sgttype in ['npub_ad', 'ad_npub', 'ad']:
            rem = len % int(self.opts.block_size_ad/8)
        else:
            rem = len % int(self.opts.block_size/8)

        pad = True if (rem > 0 and padmode > 0) \
                or (len == 0 and (padmode == 2 or padmode == 4)) \
                or (rem == 0 and len > 0 and padmode > 2) \
                else False

        if (pad):
            if (self.opts.cc_pad_style == 1):
                pad = "80"
            elif (self.opts.cc_pad_style == 2):
                if (sgttype == 'ad'):
                    pad = "03"
                else:
                    pad = "02"
            elif (self.opts.cc_pad_style == 3):
                pad = "01"
            else:
                pad = "00"
        else:
            pad = ""

        return (data + pad)


    def wr_cc_hls_segment(self, f, data, eoi, sgt, output=False):
        len  = lenbytes(data)
        ad_type = ['npub_ad', 'ad_npub', 'ad']
        # Add extra padding bits when block_size_ad < block_size_d
        if sgt in ad_type:
            blkbytes = int(self.opts.block_size_ad/8)
            extra_padding = int(self.opts.block_size/8) - int(self.opts.block_size_ad/8)
        else:
            blkbytes = int(self.opts.block_size/8)
            extra_padding = 0
        data_type = ('ct', 'ct_tag', 'pt')
        cipher_type = ('ct', 'ct_tag')
        if (not output):
            if sgt in ad_type:
                data = self.cc_pad(data, self.opts.cc_pad_ad, sgt)
            elif sgt in data_type:
                if (sgt in cipher_type and self.opts.ciph_exp):
                    # do not pad for input to decryption operation for
                    # ciphertext expansion
                    pass
                else:
                    # padding
                    data = self.cc_pad(data, self.opts.cc_pad_d, sgt)
        data = data + "00"*((blkbytes - lenbytes(data)) % blkbytes)

        tot_blk = int(math.ceil(lenbytes(data)/blkbytes))
        # tot_blk = 1 if tot_blk == 0 else tot_blk

        rem = True if (lenbytes(data) % blkbytes) > 0 else False
        partial = self.partial if sgt in data_type else 0

        sgt_type = 'ad'   if (sgt in ad_type  ) else \
                   'data' if (sgt in data_type) else sgt
        sgt_no = getattr(CC_Segment, sgt_type).value

        (is_eoi, is_eot) = (0,0)
        for j in range(tot_blk):
            txt = data[int(j*blkbytes*2):int((j+1)*blkbytes*2)]+extra_padding*"00"
            if (len >= blkbytes):
                lenblk = blkbytes
                len = len-blkbytes
            else:
                lenblk = len
                len = 0
            if (j == tot_blk-1):
                (is_eoi, is_eot) = (eoi, 1)

            if (output):
                f.write("{},{}\n".format(txt,lenblk))
            else:
                f.write("{},{},{},{},{},{}\n".format(
                    txt,lenblk,sgt_no,is_eoi,is_eot,partial))

        if (self.opts.ciph_exp and output and sgt == 'pt'):
            # Add an empty write output for plaintext data in
            # ciphertext expansion
            if ((lenbytes(data) % int(self.opts.block_size/8)) == 0):
                f.write("{},{}\n".format('0'*blkbytes*2,0))
            return


    def gen_cc_hls(self):
        if not self.opts.cc_hls:
            return
        # ==========
        # DI file
        # ==========
        file_path = os.path.join(self.opts.dest, HLS_CC_DI_FILE)
        f = open(file_path, 'a', newline='')
        decrypt = 1 if self.decrypt else 0
        new_key = 1 if self.new_key else 0
        f.write('#NEW\n\tMessage Number #{}\n{}\n'.format(self.msg_id, decrypt))
        f.write('#KEY\n{}\n{}\n'.format(new_key, self.key))

        # Write Segments
        msg_format = get_msg_format(self.opts.msg_format,0,self.decrypt, self.hashop)
        for i, sgt in enumerate(msg_format):
            # Data getter
            data = self.get_data(sgt)
            eoi  = int(self.is_last_vld_segment(sgt, msg_format))
            self.wr_cc_hls_segment(f, data, eoi, sgt)

        f.write("#END\n\n")
        f.close()

        # ==========
        # DO file
        # ==========
        file_path = os.path.join(self.opts.dest, HLS_CC_DO_FILE)
        f = open(file_path, 'a', newline='')
        f.write('#NEW\n\tMessage Number #{}\n'.format(self.msg_id))
        msg_format = get_msg_format(self.opts.msg_format,1,self.decrypt, self.hashop)
        for i, sgt in enumerate(msg_format):
            data = self.get_data(sgt)
            self.wr_cc_hls_segment(f, data, eoi, sgt, True)
        f.write("#END\n\n")
        f.close()


    def gen_nist_tv(self):
        if not self.opts.human_readable:
            return
        file_path = os.path.join(self.opts.dest, 'test_vectors.txt')
        f = open(file_path, 'a', newline='')
        f.write("#### Msg {:>3}\n".format(self.msg_id))
        attrs = ['key', 'npub', 'nsec_pt', 'ad', 'pt', 'hash', 'nsec_ct', 'ct', 'tag', 'hash_tag']
        if getattr(self,'hash_tag')=='':
            hashop = False
        else:
            hashop = True
        for attr in attrs:
            if hashop:
                if attr in ['key','npub','ad','pt','ct','tag']:
                    continue
            if not hashop:
                if attr in ['hash','hash_tag']:
                    continue
            if attr in ['nsec_pt', 'nsec_ct']:
                if (self.opts.nsec_size <= 0):
                    continue
            f.write("{:7} = {}\n".format(attr, getattr(self, attr)))
        f.write('\n')
        f.close()

# ======================
# Construct a data set
# ======================
def gen_data(bytes: int, mode=0, init='06') -> str:
    """ Generate random data """
    if (bytes == 0):
        return ''
    else:
        if (mode ==0):
            return '{d:0{s}X}'.format(s=bytes*2, d=random.randrange(256**bytes))
        else:
            init = int(init, 16)
            data = ''.join('{0:02X}'.format((j+init)%256) for j in range(bytes))
            return data

def gen_dataset(opts, routine, start_msg_no, start_key_no, mode=0):
    '''
    Generate random dataset based on the specified routine with the following
    format: [[NEW_KEY(Boolean), Encryption/Decryption(Boolean,
              AD_SIZE, DATA_SIZE],
              ...,
            ]
    '''
    dataset = []
    key = ''
    npub = ''
    nsec = ''
    ad = ''
    new_key = 0
    key_id = start_key_no-1

    def get_running_value(size):
        a = ['{:02X}'.format(int(i % 256)) for i in range(0,int(size))]
        return "".join(a)

    # print(routine)
    for i, tv in enumerate(routine):
        hashop = tv[4]

        if hashop:
            new_key = 0
            decrypt = False
        else:
            new_key   = 1 if i == 0 else tv[0]
            decrypt = tv[1]

        if mode == 2:
            key  = get_running_value(opts.key_size/8)
            npub = get_running_value(opts.npub_size/8)
            nsec = get_running_value(opts.nsec_size/8)
            ad   = get_running_value(tv[2])
            data = get_running_value(tv[3])

        elif mode == 1:
            key  = '55'*int(opts.key_size/8)
            npub = 'B0'*int(opts.npub_size/8)
            nsec = '66'*int(opts.nsec_size/8)
            ad   = 'A0'*tv[2]
            data = 'FF'*tv[3]

        else:
            key  = gen_data(int(opts.key_size/8),   mode, '55')
            npub = gen_data(int(opts.npub_size/8),  mode, 'B0')
            nsec = gen_data(int(opts.nsec_size/8),  mode, '66')
            ad   = gen_data(tv[2],          mode, 'A0')
            data = gen_data(tv[3],          mode, 'FF')

        if new_key == 0 and not hashop:
            key = dataset[i-1].key
            #! Automatically use old value for decryption
            #! if the same key is used for the same ad and plaintext size
            if (decrypt and not dataset[i-1].decrypt
                and tv[2] == lenbytes(dataset[i-1].ad)
                and tv[3] == lenbytes(dataset[i-1].pt)):
                npub = dataset[i-1].npub
                nsec = dataset[i-1].nsec_pt
                ad   = dataset[i-1].ad
                data = dataset[i-1].pt

        key_id = key_id + new_key
        if key_id < 0:
            key_id = 0

        dataset.append(TestVector(opts, i+start_msg_no, key_id,
                                  new_key, decrypt,
                                  key, npub, nsec, ad, data, hashop))
    return dataset, i+start_msg_no, key_id

def gen_single(opts, start_msg_no, start_key_no, index):
    if (opts.verbose):
        print('gen_single')
    dataset = []
    decrypt = True if opts.gen_single[index][0] == 1 else False
    hashop  = True if opts.gen_single[index][0] == 2 else False
    new_key = not hashop
    dataset.append(TestVector(opts, start_msg_no, start_key_no,
                              new_key, decrypt,
                              opts.gen_single[index][1], opts.gen_single[index][2],
                              opts.gen_single[index][3], opts.gen_single[index][4],
                              opts.gen_single[index][5], hashop))
    if hashop:
        start_key_no = start_key_no - 1
    return dataset, start_msg_no, start_key_no

def gen_random(opts, start_msg_no, start_key_no):
    if (opts.verbose):
        print('gen_random')
    routine = []
    for i in range(opts.gen_random):
        new_key = random.randrange(2)
        operation = random.randrange(2)
        sizeAd  = random.randrange(opts.min_ad, opts.max_ad+1)
        sizeMsg = random.randrange(opts.min_d , opts.max_d +1)
        routine.append([new_key, operation, sizeAd, sizeMsg, False])
    return gen_dataset(opts, routine,
                       start_msg_no, start_key_no,0)

def gen_test_combined(opts, start_msg_no, key_no):
    if (opts.verbose):
        print('gen_test_combined')
    bsa = opts.block_size_ad if opts.block_size_ad != None else opts.block_size
    bsd = opts.block_size
    bsa, bsd = int(bsa/8), int(bsd/8)
    (start, stop, mode) = opts.gen_test_combined

    routine =  [[True ,     False,      0,         0        , False],
                [False,     True,       0,         0        , False],
                [False,     True,       0,         0        , True],
                [True ,     False,      1,         0        , False],
                [False,     True,       1,         0        , False],
                [False,     True,       0,         1        , True],
                [True ,     False,      0,         1        , False],
                [False,     True,       0,         1        , False],
                [False,     True,       0,         2        , True],
                [True ,     False,      1,         1        , False],
                [False,     True,       1,         1        , False],
                [False,     True,       0,         3        , True],
                [True ,     False,      2,         2        , False],
                [False,     True,       2,         2        , False],
                [False,     True,       0,         4        , True],
                [True ,     False,      bsa-1,     bsd-1    , False],
                [False,     True,       bsa-1,     bsd-1    , False],
                [False,     True,       0,         bsd-1    , True],
                [True ,     False,      bsa,       bsd      , False],
                [False,     True,       bsa,       bsd      , False],
                [False,     True,       0,         bsd+1    , True],
                [True ,     False,      bsa+1,     bsd+1    , False],
                [False,     True,       bsa+1,     bsd+1    , False],
                [False,     True,       0,         bsd+2    , True],
                [True ,     False,      bsa*2,     bsd*2    , False],
                [False,     True,       bsa*2,     bsd*2    , False],
                [False,     True,       0,         bsd*2    , True],
                [True ,     False,      bsa*2+1,   bsd*2+1  , False],
                [False,     True,       bsa*2+1,   bsd*2+1  , False],
                [False,     True,       0,         bsd*2+1  , True],
                [True ,     False,      bsa*3,     bsd*3    , False],
                [False,     True,       bsa*3,     bsd*3    , False],
                [False,     True,       0    ,     bsd*3    , True]]

    return gen_dataset(opts, routine[start-1:stop],
                       start_msg_no, key_no, mode)

def gen_hash(opts, start_msg_no):
    if (opts.verbose):
        print('gen_hash')
    bsa = opts.block_size_ad if opts.block_size_ad != None else opts.block_size
    bsd = opts.block_size
    bsa, bsd = int(bsa/8), int(bsd/8)
    (start, stop, mode) = opts.gen_hash

    routine =  [[False,     False,      0,         0        , True],
                [False,     False,      0,         1        , True],
                [False,    False,       0,         2        , True],
                [False,     False,      0,         3        , True],
                [False,    False,       0,         4        , True],
                [False,     False,      0,         5        , True],
                [False,    False,       0,         6        , True],
                [False,     False,      0,         7        , True],
                [False,    False,       0,         bsd-2    , True],
                [False,     False,      0,         bsd-1    , True],
                [False,    False,       0,         bsd      , True],
                [False,     False,      0,         bsd+1    , True],
                [False,    False,       0,         bsd+2    , True],
                [False,     False,      0,         bsd*2    , True],
                [False,    False,       0,         bsd*2+1  , True],
                [False,     False,      0,         bsd*3    , True],
                [False,    False,       0,         bsd*3+1  , True],
                [False,     False,      0,         bsd*4    , True],
                [False,    False,       0,         bsd*4+1  , True],
                [False,     False,      0,         bsd*5    , True],
                [False,    False,       0,         bsd*5+1  , True]]

    return gen_dataset(opts, routine[start-1:stop],
                       start_msg_no, 0, mode)

def gen_test_routine(opts, start_msg_no, start_key_no):
    if (opts.verbose):
        print('gen_test_routine')
    bsa = opts.block_size_ad if opts.block_size_ad != None else opts.block_size
    bsd = opts.block_size
    bsa, bsd = int(bsa/8), int(bsd/8)
    (start, stop, mode) = opts.gen_test_routine
    routine =  [[True ,     False,      0,         0        , False],
                [False,     True,       0,         0        , False],
                [True ,     False,      1,         0        , False],
                [False,     True,       1,         0        , False],
                [True ,     False,      0,         1        , False],
                [False,     True,       0,         1        , False],
                [True ,     False,      1,         1        , False],
                [False,     True,       1,         1        , False],
                [True ,     False,      bsa,       bsd      , False],
                [False,     True,       bsa,       bsd      , False],
                [True ,     False,      bsa-1,     bsd-1    , False],
                [False,     True,       bsa-1,     bsd-1    , False],
                [True ,     False,      bsa+1,     bsd+1    , False],
                [False,     True,       bsa+1,     bsd+1    , False],
                [True ,     False,      bsa*2,     bsd*2    , False],
                [False,     True,       bsa*2,     bsd*2    , False],
                [True ,     False,      bsa*3,     bsd*3    , False],
                [False,     True,       bsa*3,     bsd*3    , False],
                [True ,     False,      bsa*4,     bsd*4    , False],
                [False,     True,       bsa*4,     bsd*4    , False],
                [True ,     False,      bsa*5,     bsd*5    , False],
                [False,     True,       bsa*5,     bsd*5    , False]]
    return gen_dataset(opts, routine[start-1:stop],
                       start_msg_no, start_key_no, mode)

def gen_tv_and_write_files(opts, dataset):
    '''This utility function takes the dataset and generates the test vectors and
    writes then to the appropriate files
    '''
    if not os.path.exists(opts.dest):
        os.makedirs(opts.dest, exist_ok = True)

    print_header(opts)
    for tv in dataset:
        tv.gen_tv()
        tv.gen_nist_tv()
        tv.gen_cc_hls()

    # Add EOF tag
    for file_name in [opts.pdi_file, opts.do_file, opts.sdi_file]:
        file_path = os.path.join(opts.dest, file_name)
        with open(file_path, 'a') as f:
            f.write('###EOF\n')


def determine_params(opts):
    '''This untility function will read in the parameters of the reference
    implementation api.h file and update the opts dict
    '''
    algo_api_h = ctgen_get_supercop_dir() / 'crypto_aead' / opts.aead / "ref/api.h"
    if not os.path.exists(algo_api_h):
        sys.exit(f"{algo_api_h} does not exist. Ensure --aead is correct")
    with open(algo_api_h, 'r') as f:
        api_h = f.read()
    log.debug(api_h)
    for line in api_h.splitlines():
        if "KEYBYTES" in line:
            opts.key_size = 8 * int(line.split()[-1])
        elif "NPUBBYTES" in line:
            opts.npub_size = 8 * int(line.split()[-1])
        elif "NSECBYTES" in line:
            opts.nsec_size = 8 * int(line.split()[-1])
        elif "NSECBYTES" in line:
            opts.nsec_size = 8 * int(line.split()[-1])
        elif "CRYPTO_ABYTES" in line:
            opts.tag_size = 8 * int(line.split()[-1])
    if opts.hash:
        algo_hash_api_h = ctgen_get_supercop_dir() / 'crypto_hash' / opts.hash / "ref/api.h"
        if not os.path.exists(algo_hash_api_h):
            sys.exit(f"{algo_hash_api_h} did not exists. Ensure --hash is correct")
        with open(algo_hash_api_h, 'r') as f:
            hash_api_h = f.read()
        log.debug(hash_api_h)
        for line in hash_api_h.splitlines():
            if "CRYPTO_BYTES" in line:
                opts.message_digest_size = 8 * int(line.split()[-1])

def blanket_message_hash_test(block_size_msg_digest):
    routine = []
    for hash_size in range(4*block_size_msg_digest//8):
        routine.append([False, False, False, hash_size, True])
    return routine

def basic_hash_sizes(block_size_msg_digest):
    routine =  [[False, False, 0,                          0, True],
                [False, False, 0, 5*block_size_msg_digest//8, True],
                [False, False, 0, 4*block_size_msg_digest//8, True],
                [False, False, 0,                       1536, True],
                [False, False, 0,                         64, True],
                [False, False, 0,                         16, True],]
    return routine

def blanket_message_aead_test(opts):
    routine = []
    for ad_size in range(2*opts.block_size_ad//8):
        for mess_size in range(2*opts.block_size//8):
            routine.append([True, False, ad_size, mess_size,False])
    return routine

def basic_aead_sizes(new_key, enc_dec, block_size_ad, block_size_message):
    routine =  [[new_key,     enc_dec,  5*block_size_ad//8,                          0, False],
                [new_key,     enc_dec,  4*block_size_ad//8,                          0, False],
                [new_key,     enc_dec,                1536,                          0, False],
                [new_key,     enc_dec,                  64,                          0, False],
                [new_key,     enc_dec,                  16,                          0, False],
                [new_key,     enc_dec,                   0,    5*block_size_message//8, False],
                [new_key,     enc_dec,                   0,    4*block_size_message//8, False],
                [new_key,     enc_dec,                   0,                       1536, False],
                [new_key,     enc_dec,                   0,                         64, False],
                [new_key,     enc_dec,                   0,                         16, False],
                [new_key,     enc_dec,  5*block_size_ad//8,    5*block_size_message//8, False],
                [new_key,     enc_dec,  4*block_size_ad//8,    4*block_size_message//8, False],
                [new_key,     enc_dec,                1536,                       1536, False],
                [new_key,     enc_dec,                  64,                         64, False],
                [new_key,     enc_dec,                  16,                         16, False]]
    return routine


def gen_benckmark_routine(opts):
    if (opts.verbose):
        print("gen_benckmark_routine")
    if not opts.aead or not opts.block_size or not opts.block_size_ad:
        sys.exit("--aead algorithm & --block_size & --block_size_ad must be specified")
    if opts.hash and not opts.block_size_msg_digest:
        sys.exit("If --hash algorithm is desired --block_size_msg_digest is required")
    log.debug(f"original options \n{opts}\n")

    # Update parameters based on api.h
    determine_params(opts)
    orig_dest=opts.dest
    if opts.hash:
        data = gen_dataset(opts, blanket_message_hash_test(opts.block_size_msg_digest), 1, 1)
        opts.dest = os.path.join(orig_dest, 'blanket_hash_test')
        gen_tv_and_write_files(opts, data[0])
        print(f'Generated: {os.path.abspath(opts.dest)}')

        data = gen_dataset(opts, basic_hash_sizes(opts.block_size_msg_digest), 1, 1)
        opts.dest = os.path.join(orig_dest, 'basic_hash_sizes')
        gen_tv_and_write_files(opts, data[0])
        print(f'Generated: {os.path.abspath(opts.dest)}')

    # Power measure runs
    data = gen_dataset(opts, [[True, False, 0, 16, False]], 1, 1)
    opts.dest = os.path.join(orig_dest, 'pow_0_16')
    gen_tv_and_write_files(opts, data[0])
    print(f'Generated: {os.path.abspath(opts.dest)}')
    data = gen_dataset(opts, [[True, False, 16, 0, False]], 1, 1)
    opts.dest = os.path.join(orig_dest, 'pow_16_0')
    gen_tv_and_write_files(opts, data[0])
    print(f'Generated: {os.path.abspath(opts.dest)}')
    data = gen_dataset(opts, [[True, False, 16, 16, False]], 1, 1)
    opts.dest = os.path.join(orig_dest, 'pow_16_16')
    gen_tv_and_write_files(opts, data[0])
    print(f'Generated: {os.path.abspath(opts.dest)}')

    data = gen_dataset(opts, [[True, False, 0, 64, False]], 1, 1)
    opts.dest = os.path.join(orig_dest, 'pow_0_64')
    gen_tv_and_write_files(opts, data[0])
    print(f'Generated: {os.path.abspath(opts.dest)}')
    data = gen_dataset(opts, [[True, False, 64, 0, False]], 1, 1)
    opts.dest = os.path.join(orig_dest, 'pow_64_0')
    gen_tv_and_write_files(opts, data[0])
    print(f'Generated: {os.path.abspath(opts.dest)}')
    data = gen_dataset(opts, [[True, False, 64, 64, False]], 1, 1)
    opts.dest = os.path.join(orig_dest, 'pow_64_64')
    gen_tv_and_write_files(opts, data[0])
    print(f'Generated: {os.path.abspath(opts.dest)}')

    data = gen_dataset(opts, [[True, False, 0, 1536, False]], 1, 1)
    opts.dest = os.path.join(orig_dest, 'pow_0_1536')
    gen_tv_and_write_files(opts, data[0])
    print(f'Generated: {os.path.abspath(opts.dest)}')
    data = gen_dataset(opts, [[True, False, 1536, 0, False]], 1, 1)
    opts.dest = os.path.join(orig_dest, 'pow_1536_0')
    gen_tv_and_write_files(opts, data[0])
    print(f'Generated: {os.path.abspath(opts.dest)}')
    data = gen_dataset(opts, [[True, False, 1536, 1536, False]], 1, 1)
    opts.dest = os.path.join(orig_dest, 'pow_1536_1536')
    gen_tv_and_write_files(opts, data[0])
    print(f'Generated: {os.path.abspath(opts.dest)}')

    data = gen_dataset(opts, [[True, False, 0, 4*opts.block_size//8, False]], 1, 1)
    opts.dest = os.path.join(orig_dest, 'pow_0_4x')
    gen_tv_and_write_files(opts, data[0])
    print(f'Generated: {os.path.abspath(opts.dest)}')
    data = gen_dataset(opts, [[True, False, 4*opts.block_size_ad//8, 0, False]], 1, 1)
    opts.dest = os.path.join(orig_dest, 'pow_4x_0')
    gen_tv_and_write_files(opts, data[0])
    print(f'Generated: {os.path.abspath(opts.dest)}')
    data = gen_dataset(opts, [[True, False, 4*opts.block_size_ad//8, 4*opts.block_size//8, False]], 1, 1)
    opts.dest = os.path.join(orig_dest, 'pow_4x_4x')
    gen_tv_and_write_files(opts, data[0])
    print(f'Generated: {os.path.abspath(opts.dest)}')

    data = gen_dataset(opts, [[True, False, 0, 5*opts.block_size//8, False]], 1, 1)
    opts.dest = os.path.join(orig_dest, 'pow_0_5x')
    gen_tv_and_write_files(opts, data[0])
    print(f'Generated: {os.path.abspath(opts.dest)}')
    data = gen_dataset(opts, [[True, False, 5*opts.block_size_ad//8, 0, False]], 1, 1)
    opts.dest = os.path.join(orig_dest, 'pow_5x_0')
    gen_tv_and_write_files(opts, data[0])
    print(f'Generated: {os.path.abspath(opts.dest)}')
    data = gen_dataset(opts, [[True, False, 5*opts.block_size_ad//8, 5*opts.block_size//8, False]], 1, 1)
    opts.dest = os.path.join(orig_dest, 'pow_5x_5x')
    gen_tv_and_write_files(opts, data[0])
    print(f'Generated: {os.path.abspath(opts.dest)}')

    data = gen_dataset(opts, blanket_message_aead_test(opts), 1, 1)
    opts.dest = os.path.join(orig_dest, 'kats_for_verification')
    gen_tv_and_write_files(opts, data[0])
    print(f'Generated: {os.path.abspath(opts.dest)}')

    # Ensure new key
    routine_new_key = [[True, False, 0,0, False]]
    routine_new_key += basic_aead_sizes(True, False, opts.block_size_ad, opts.block_size)
    routine_new_key += basic_aead_sizes(True, True, opts.block_size_ad, opts.block_size)
    data_enc = gen_dataset(opts, routine_new_key, 1, 1)
    opts.dest = os.path.join(orig_dest, 'generic_aead_sizes_new_key')
    gen_tv_and_write_files(opts, data_enc[0])
    print(f'Generated: {os.path.abspath(opts.dest)}')

    # Ensure at least one new key
    routine_reuse_key = [[True, False, 0,0, False]]
    routine_reuse_key += basic_aead_sizes(False, False, opts.block_size_ad, opts.block_size)
    routine_reuse_key += basic_aead_sizes(False, True, opts.block_size_ad, opts.block_size)
    data_enc = gen_dataset(opts, routine_reuse_key, 1, 1)
    opts.dest = os.path.join(orig_dest, 'generic_aead_sizes_reuse_key')
    gen_tv_and_write_files(opts, data_enc[0])
    print(f'Generated: {os.path.abspath(opts.dest)}')
